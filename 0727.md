2020/07/27

完成lab6实验题：

#### 问题一：原理：使用条件变量之后，分别从线程和操作系统的角度而言读取字符的系统调用是阻塞的还是非阻塞的？

答案：对线程是阻塞的，对操作系统是非阻塞的。

#### 问题二：如果要让用户线程能够使用 `Vec` 等，需要做哪些工作？如果要让用户线程能够使用大于其栈大小的动态分配空间，需要做哪些工作？

答案：(1)必须实现用户态下内存申请的系统调用；（2）需要通过系统调用来向操作系统内核申请更大的空间。

#### 实验：实现get_tid()

用户态下，需要加入：

```rust
pub fn sys_gettid() -> isize {

  syscall(SYSCALL_GETTID, 0, 0, 0, 0, 0, 0)

}
```

内核态下，需要加入：

```rust
SYS_GETTID => sys_gettid(),
```

最后，要实现sys_gettid():

```rust
pub(super) fn sys_gettid() -> SyscallResult {

  SyscallResult::Proceed(PROCESSOR.lock().current_thread().id)

}
```

#### 实验：实现进程复制sys_fork()

线程跟进程比，难度上涨了一大截，尽管努力尝试，但是还是没法处理好进程所有的线程的问题，所以最后只好作罢了。

#### 实验：将一个文件打包进用户镜像，并让一个用户进程读取它并打印其内容。需要实现 `sys_open`，将文件描述符加入线程的 `descriptor` 中，然后通过 `sys_read` 来读取。